# language translator


#TODO: consider to move "expandCode" and "expandCode1" and validation functions from vpu.py to this file
#TODO: consider to improve "expandCode" etc to handle a more simple syntax for the code in language.conf



                    {'add':("Reg[A2] = Reg[A2] + Reg[A1]",
                            "incPC()"),
                     'and':("Reg[A2] = Reg[A1] & Reg[A2]",
                            "incPC()"),
                     'dec':("Reg[A1] = Reg[A1] - 1",
                            "incPC()"),
                     'div':("Reg[A2] = Reg[A1] / Reg[A2]",
                            "incPC()"),
                     'halt':("raise EndOfProgram"),
                     'inc':("Reg[A1] = Reg[A1] + 1",
                            "incPC()"),
                     'jneg':("if Reg[A1] < 0:",
                             " if type(A2) == type(''):",
                             "  add = self.ParseLabelP(A2)",
                             " else: add = A2",
                             " self.PC = add",
                             "else: self.PC = self.PC + 1"),
                     'jpos':("if Reg[A1] > 0:",
                             " if type(A2) == type(''):",
                             "  add = self.ParseLabelP(A2)",
                             " else: add = A2",
                             " self.PC = add",
                             "else: self.PC = self.PC + 1"),
                     'jsr':("if type(A1) == type(''):",
                            " add = self.ParseLabelP(A1)",
                            "else: add = A1",
                            "self.push(self.PC + 1)",
                            "self.PC = add"),
                     'jump':("if type(A1) == type(''):",
                             " try: add = self.labelp[A1]",
                             " except KeyError: raise LabelError",
                             "else: add = A1",
                             "self.PC = add"),
                     'jumpi':("self.PC = Reg[A1]"),
                     'jnzero':("if Reg[A1] != 0:",
                              " if type(A2) == type(''):",
                              "  add = self.ParseLabelP(A2)",
                              " else: add = i[2]",
                              " self.PC = add",
                              "else: self.PC = self.PC + 1"),
                     'jzero':("if Reg[A1] == 0:",
                              " if type(A2) == type(''):",
                              "  add = self.ParseLabelP(A2)",
                              " else: add = i[2]",
                              " self.PC = add",
                              "else: self.PC = self.PC + 1"),
                     'load':("if type(A1) == type(''):",
                             " try: add = self.labelm[A1]",
                             " except KeyError: raise LabelError",
                             "else: add = A1",
                             "try: foo = self.MLoad(add)",
                             "except IndexError: raise OutOfMemory(add)",
                             "Reg[A2] = foo",
                             "incPC()"),
                     'loadi':("add = Reg[A1]",
                              "try: foo = self.MLoad(add)",
                              "except IndexError: raise OutOfMemory(add)",
                              "Reg[A2] = foo",
                              "incPC()"),
                     'loadn':("if type(A1) == type(''):",
                              " v = self.ParseLabel(A1)",
                              "else: v = A1",
                              "Reg[A2] = v",
                              "incPC()"),
                     'loado':("add = Reg[self.FPn]+A1",
                              "try: foo = self.MLoad(add)",
                              "except IndexError: raise OutOfMemory(add)",
                              "Reg[A2] = foo",
                              "incPC()"),
                     'mod':("Reg[A2] = Reg[A1] % Reg[A2]",
                            "incPC()"),
                     'mul':("Reg[A2] = Reg[A1] * Reg[A2]",
                            "incPC()"),
                     'or':("Reg[A2] = Reg[A1] | Reg[A2]",
                           "incPC)"),
                     'pop':("Reg[A1] = self.pop()",
                            "incPC()"),
                     'push':("self.push(Reg[A1])",
                             "incPC()"),
                     'rtn':("self.PC = self.pop()"),
                     'store':("if type(A2) == type (''):",
                              " try: add = self.labelm[A2]",
                              " except KeyError: raise LabelError",
                              "else: add = A2",
                              "foo = Reg[A1]",
                              "try: self.MStore(add,foo)",
                              "except IndexError: raise OutOfMemory(add)",
                              "incPC()"),
                     'storei':("try: self.MStore(Reg[A2],Reg[A1])",
                               "except IndexError:",
                               " raise OutOfMemory(Reg[A2])",
                               "incPC()"),
                     'storen':("if type(A1) == type(''):",
                               " r = self.ParseLabel(A1)",
                               "else: r = A1",
                               "Reg[A2]=r",
                               "incPC()"),
                     'storeo':("add = Reg[self.FPn]+A2",
                               "try:self.MStore(add,Reg[A1])",
                               "except IndexError:",
                               " raise OutOfMemory(add)",
                               "incPC()"),
                     'storer':("Reg[A2] = Reg[A1]",
                               "incPC()"),
                     'sub':("Reg[A2] = Reg[A1] - Reg[A2]",
                            "incPC()"),
                     'xor':("Reg[A2] = Reg[A1] ^ Reg[A2]",
                            "incPC()"),
                     'nop':("incPC()"),
                     'zero':("Reg[A1] = 0",
                             "incPC()")}